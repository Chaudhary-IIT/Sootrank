{% extends "student_base.html" %}
{% load static %}
{% block title %}Course Pre-Registration{% endblock %}
{% block nav_registration_active %} active{% endblock %}

{% block content %}
<div class="container py-3" style="max-width:1100px;">
  {% if messages %}
    {% for message in messages %}
      <div class="alert alert-{{ message.tags }} alert-dismissible fade show">{{ message }}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      </div>
    {% endfor %}
  {% endif %}

  <div class="d-flex justify-content-between align-items-start mb-3">
    <div>
      <h2 class="h4 mb-0">Course Pre-Registration</h2>
      {% if window_open %}
    <div class="alert alert-success py-2 mb-3">
        <i class="fa-solid fa-unlock me-2"></i>
        Pre-registration window is <strong>OPEN</strong>.
    </div>
{% else %}
    <div class="alert alert-danger py-2 mb-3">
        <i class="fa-solid fa-lock me-2"></i>
        Pre-registration window is <strong>CLOSED</strong>.
    </div>
{% endif %}

      <p class="text-muted small mb-0">Choose one course per slot for Semester {{ computed_semester }}.</p>
    </div>
    <div>
      <span class="badge bg-primary">Semester {{ computed_semester }}</span>
    </div>
  </div>

  {% if new_cycle %}
  <div class="alert alert-info small">A new pre-registration cycle has started.</div>
  {% endif %}

  <form id="courseForm" method="post" action="{% url 'prereg_page' %}" class="card p-4 shadow-sm">
    {% csrf_token %}
    <input type="hidden" name="payload" id="payloadInput">

    <div class="row g-3">
      {% comment %} Build slot panels. All selects are initially empty; JS will populate options from slot_map_json.{% endcomment %}
      {% for slot in slots %}
      <div class="col-12 col-md-6 col-lg-4">
        <div class="mb-2">
          <label class="form-label fw-semibold">Slot - {{ slot }}</label>
          <select id="slot-{{ slot }}-cat" class="form-select form-select-sm slot-cat" data-slot="{{ slot }}">
            <option value="">Select category</option>
            <option value="ALL">All courses (Slot {{ slot }})</option>
            {% for c in categories %}
            <option value="{{ c.code }}">{{ c.code }} — {{ c.label }}</option>
            {% endfor %}
          </select>
        </div>

        <div>
          <select id="slot-{{ slot }}-course" class="form-select form-select-sm slot-course" data-slot="{{ slot }}" disabled>
            <option value="">Select a category first</option>
          </select>
        </div>

        <div class="mt-1 small text-muted slot-hint" id="slot-{{ slot }}-hint"></div>
      </div>
      {% endfor %}
    </div>

    <div class="d-flex align-items-center justify-content-between mt-4">
      <div>
        <strong>Total Credits: </strong> <span id="totalCredits" class="text-success">0</span>
        <div id="creditError" class="text-danger small d-none"></div>
      </div>

      <div class="d-flex gap-2">
        <button type="button" id="resetBtn" class="btn btn-outline-secondary btn-sm" {% if not window_open %}disabled{% endif %}>Reset</button>
        <button id="submitBtn" type="submit" class="btn btn-dark btn-sm" {% if not window_open %}disabled{% endif %}>{% if preselected_by_slot %}Update{% else %}Submit{% endif %}</button>
      </div>
    </div>
  </form>

  <!-- Confirm Modal -->
  <div class="modal fade" id="confirmModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-body">
          <p class="mb-3">Confirm submission — selections will be saved as Pending (PND). Approved selections will remain locked.</p>
          <div class="d-flex justify-content-end gap-2">
            <button id="confirmCancel" class="btn btn-outline-secondary btn-sm" data-bs-dismiss="modal">Cancel</button>
            <button id="confirmProceed" class="btn btn-success btn-sm">Proceed</button>
          </div>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- JSON data -->
<script id="slot-map-data" type="application/json">{{ slot_map_json|safe }}</script>
<script id="preselected-data" type="application/json">{{ preselected_json|safe }}</script>
<script id="locked-slots-data" type="application/json">{{ locked_slots_json|safe }}</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const slotMap = JSON.parse(document.getElementById('slot-map-data').textContent || '{}');
  const preselected = JSON.parse(document.getElementById('preselected-data').textContent || '{}');
  const lockedSlots = JSON.parse(document.getElementById('locked-slots-data').textContent || '[]');

  const minCredit = {{ min_credit|default:12 }};
  const maxCredit = {{ max_credit|default:22 }};

  // Utility: populate course select based on chosen category
  function populateCourseSelect(slot, chosenCat) {
    const courseSel = document.getElementById(`slot-${slot}-course`);
    courseSel.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = chosenCat ? 'Select a course' : 'Select a category first';
    courseSel.appendChild(placeholder);

    if (!chosenCat) {
      courseSel.disabled = true;
      return;
    }

    let optionsArray = [];

    if (chosenCat === 'ALL') {
      // aggregate all categories for this slot
      const byCat = slotMap[slot] || {};
      Object.keys(byCat).forEach(cat => {
        (byCat[cat] || []).forEach(c => optionsArray.push({...c, cat: cat}));
      });
    } else {
      optionsArray = (slotMap[slot] && slotMap[slot][chosenCat]) ? slotMap[slot][chosenCat].slice() : [];
    }

    // If no courses available
    if (!optionsArray.length) {
      const noOpt = document.createElement('option');
      noOpt.value = '';
      noOpt.disabled = true;
      noOpt.selected = true;
      noOpt.textContent = 'No courses available for the selected category';
      courseSel.appendChild(noOpt);
      courseSel.disabled = true;
      return;
    }

    // Build options
    optionsArray.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.code;
      opt.textContent = `${c.name} (${c.code}) - ${c.credits} cr`;
      opt.dataset.credits = String(c.credits || 0);
      opt.dataset.category = chosenCat === 'ALL' ? (c.cat || '') : chosenCat;
      courseSel.appendChild(opt);
    });

    courseSel.disabled = false;

    // apply preselected if present
    const pre = preselected[slot];
    if (pre) {
      const idx = Array.from(courseSel.options).findIndex(o => o.value === pre);
      if (idx >= 0) courseSel.selectedIndex = idx;
    }
  }

  // initialise slots
  const slots = Object.keys(slotMap || {});
  slots.forEach(slot => {
    const catSel = document.getElementById(`slot-${slot}-cat`);
    const courseSel = document.getElementById(`slot-${slot}-course`);
    const hint = document.getElementById(`slot-${slot}-hint`);

    // If slot locked, show locked and disable selects
    if (lockedSlots.includes(slot)) {
      // if preselected exists, show the course and disable selects
      const code = preselected[slot];
      if (code) {
        // find course name & credits from slotMap
        let found = null;
        Object.keys(slotMap[slot] || {}).forEach(cat => {
          (slotMap[slot][cat] || []).forEach(c => {
            if (c.code === code) found = c;
          });
        });
        if (found) {
          courseSel.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = found.code;
          opt.textContent = `${found.name} (${found.code}) - ${found.credits} cr (Approved)`;
          opt.dataset.credits = String(found.credits || 0);
          courseSel.appendChild(opt);
        } else {
          courseSel.innerHTML = '<option value="">(Approved course not available)</option>';
        }
      } else {
        courseSel.innerHTML = '<option value="">(Approved course)</option>';
      }
      catSel.disabled = true;
      courseSel.disabled = true;
      hint.textContent = 'Approved; selection locked';
      return;
    }

    // Otherwise wire category change
    catSel.addEventListener('change', function() {
      populateCourseSelect(slot, this.value);
      updateCredits();
      // update hint
      const catText = this.value ? (this.value === 'ALL' ? 'All categories' : this.value) : '';
      hint.textContent = catText ? `Category: ${catText}` : '';
    });

    // If preselected exists (PND or older), attempt to set category automatically
    const pre = preselected[slot];
    if (pre) {
      // find category containing this course
      let catFound = '';
      Object.keys(slotMap[slot] || {}).some(cat => {
        const arr = slotMap[slot][cat] || [];
        return arr.some(c => {
          if (String(c.code).toUpperCase() === String(pre).toUpperCase()) {
            catFound = cat;
            return true;
          }
          return false;
        });
      });
      if (catFound) {
        catSel.value = catFound;
        populateCourseSelect(slot, catFound);
        // select the preselected course option
        const courseEls = courseSel.options;
        for (let i=0;i<courseEls.length;i++){
          if (courseEls[i].value.toUpperCase() === pre.toUpperCase()){
            courseSel.selectedIndex = i;
            break;
          }
        }
      }
    }

    // Course change updates credits immediately
    courseSel.addEventListener('change', updateCredits);
  });

  // Reset button
  document.getElementById('resetBtn').addEventListener('click', function() {
    // clear category/course selects for non-locked slots
    slots.forEach(slot => {
      if (lockedSlots.includes(slot)) return;
      const catSel = document.getElementById(`slot-${slot}-cat`);
      const courseSel = document.getElementById(`slot-${slot}-course`);
      catSel.value = '';
      courseSel.innerHTML = '<option value="">Select a category first</option>';
      courseSel.disabled = true;
      const hint = document.getElementById(`slot-${slot}-hint`);
      if (hint) hint.textContent = '';
    });
    updateCredits();
  });

  // Compute total credits
  function updateCredits() {
    let total = 0;
    slots.forEach(slot => {
      const courseSel = document.getElementById(`slot-${slot}-course`);
      const isLocked = lockedSlots.includes(slot);
      if (isLocked) {
        const opt = courseSel.options[courseSel.selectedIndex];
        if (opt && opt.dataset && opt.dataset.credits) total += parseInt(opt.dataset.credits || '0', 10);
      } else {
        if (!courseSel || courseSel.disabled) return;
        const opt = courseSel.options[courseSel.selectedIndex];
        if (opt && opt.value) total += parseInt(opt.dataset.credits || '0', 10);
      }
    });
    document.getElementById('totalCredits').textContent = total;
    const err = document.getElementById('creditError');
    if (total < minCredit) { err.textContent = `Minimum ${minCredit} credits required`; err.classList.remove('d-none'); }
    else if (total > maxCredit) { err.textContent = `Maximum ${maxCredit} credits allowed`; err.classList.remove('d-none'); }
    else { err.classList.add('d-none'); }
  }

  // On submit, validate and show confirm modal
  document.getElementById('courseForm').addEventListener('submit', function(e) {
    e.preventDefault();
    const total = parseInt(document.getElementById('totalCredits').textContent || '0', 10);
    if (total < minCredit || total > maxCredit) {
      alert('Please ensure total credits are within allowed range.');
      return;
    }
    // build payload
    const selections = [];
    slots.forEach(slot => {
      const courseSel = document.getElementById(`slot-${slot}-course`);
      if (!courseSel || courseSel.disabled) {
        // If locked, we still include it so server knows preselected (locked) ones remain
        const pre = preselected[slot];
        if (pre) {
          selections.push({ slot: slot, course_code: pre, category: 'LOCKED' });
        }
        return;
      }
      const opt = courseSel.options[courseSel.selectedIndex];
      if (opt && opt.value) {
        selections.push({
          slot: slot,
          course_code: opt.value,
          category: opt.dataset.category || '',
          credits: parseInt(opt.dataset.credits || '0', 10)
        });
      }
    });

    const payload = { semester: {{ computed_semester }}, selections: selections };
    document.getElementById('payloadInput').value = JSON.stringify(payload);

    // show confirm modal
    const confirmModal = new bootstrap.Modal(document.getElementById('confirmModal'));
    confirmModal.show();

    document.getElementById('confirmProceed').onclick = function() {
      confirmModal.hide();
      document.getElementById('courseForm').submit();
    };
  });

  // initial credits calculation (PND/ENR preselected count automatically)
  updateCredits();
});
</script>

{% endblock %}
